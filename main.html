<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="description" content="main.html">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Untitled</title>
        <link rel="stylesheet" href="style.css">
        <link rel="author" href="humans.txt">
        <script src="three.js"></script>
        <script src="GPUComputationRenderer.js"></script>

        <!-- shader to update positions and velocities of the particles. -->
        <script id="particleCalculator" type="x-shader/x-fragment">
            uniform float deltaTime;
            uniform vec2 mousePos;
            const float width = resolution.x;
            const float k = 0.1;
            const float weight = 0.05;
            const float gravity = 0.01;
            const float rho0 = 0.1;
            const float d = 10.0;
            const float d2 = d * d;
            const float pi = 3.1415926535897932384626;
            const float poly6Parameter = 315.0 / (64.0 * pi);
            const float poly6dParameter = 945.0 / (32.0 * pi * d);

            float poly6(float r)
            {
                float rd = min(r / d, 1.0);
                float r2 = (1.0 - rd * rd) / d;
                return poly6Parameter / (r2 * r2 * r2);
            }

            vec2 poly6d(vec2 x)
            {
                float len2 = dot(x, x);
                if (len2 < 1e-6)
                    return vec2(0.0, 0.0);
                float r2 = max(1.0 / d2 - len2 / (d2 * d2), 0.0);
                return poly6dParameter * r2 * r2 * x;
            }

            float rho;
            float pressureParameter;

            void main()
            {
                rho = poly6(0.0);
                pressureParameter = k * (rho - rho0) / rho;

                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec4 posAndVelocity = texture2D(textureParticle, uv);
                vec2 pos = posAndVelocity.xy;
                vec2 velocity = posAndVelocity.zw;
                vec2 pressure = vec2(0.0, 0.0);
                for (float i = 0.0; i < width; ++i)
                {
                    vec2 ref = vec2(i + 0.5, 0.5) / resolution.xy;
                    vec2 pos2 = texture2D(textureParticle, ref).xy;
                    vec2 delta = pos - pos2;
                    pressure += weight * pressureParameter * poly6d(delta);
                }

                pos += velocity * deltaTime * 100.0;
                velocity += - pressure / rho - gravity * normalize(pos - mousePos);
                gl_FragColor = vec4(pos, velocity);
            }
        </script>

        <script id="vertexShader" type="x-shader/x-fragment">
            uniform sampler2D posAndVelocity;
            void main()
            {
                vec2 pos = texture2D(posAndVelocity, position.xy).xy;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, -1.0, 1.0);
                gl_PointSize = 2.0;
            }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">
            void main()
            {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        </script>

        <script>
            var PARTICLE_COUNT = 2048;
            var renderer, scene, camera, gpuCompute;
            var renderParticles;
            var particleShaderGeo, particleShaderMat;
            var particleVar, uniforms;
            var mouseX, mouseY;
            var clock = new THREE.Clock();

            window.onload = function() {
                init();
                animate();
            };

            function init()
            {
                // Initialize renderers and others.
                var width = document.getElementById('main-div').clientWidth;
                var height = document.getElementById('main-div').clientHeight;
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('main')
                });
                renderer.setSize(width, height);
                scene = new THREE.Scene();
                camera = new THREE.OrthographicCamera(0, width, 0, height, 0, 100);
                camera.lookAt(new THREE.Vector3(0, 0, -1));

                // Add event listeners.
                /*document.addEventListener('mousemove', function(e) {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                    uniforms.mousePos.value =
                        new THREE.Vector2(mouseX, mouseY);
                }, false);*/

                window.addEventListener('resize', function() {
                    var width = document.getElementById('main-div').clientWidth;
                    var height = document.getElementById('main-div').clientHeight;
                    camera.right = width;
                    camera.bottom = height;
                    renderer.setSize(width, height);
                }, false);

                // Initialize particle system.
                particleShaderGeo = new THREE.BufferGeometry();
                var referenceAttr = new Float32Array(PARTICLE_COUNT * 3);
                for (var i = 0; i < PARTICLE_COUNT; i++)
                {
                    referenceAttr[i * 3] = (i + 0.5) / PARTICLE_COUNT;
                    referenceAttr[i * 3 + 1] = 0.5;
                    referenceAttr[i * 3 + 2] = 0.0;
                    //referenceAttr[i * 3] = Math.random() * 50.0 + width / 2.0 - 25.0;
                    //referenceAttr[i * 3 + 1] = Math.random() * 50.0 + height / 2.0 - 25.0;
                    //referenceAttr[i * 3 + 2] = -1.0;
                }
                particleShaderGeo.addAttribute('position', new THREE.BufferAttribute(referenceAttr, 3));

                particleShaderMat = new THREE.ShaderMaterial({
                    uniforms: {
                        'posAndVelocity': { value: null }
                    },
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,


                    blending:       THREE.AdditiveBlending,
                    depthTest:      false,
                    transparent:    true

                })
                renderParticles = new THREE.Points(particleShaderGeo, particleShaderMat);
                scene.add(renderParticles);

                // Initialize gpu computer.
                gpuCompute = new GPUComputationRenderer(PARTICLE_COUNT, 1, renderer);
                var particleTexture = gpuCompute.createTexture();
                var textureArray = particleTexture.image.data;
                for (var i = 0; i < textureArray.length; i += 4)
                {
                    var x = Math.random() * 600.0 + width / 2.0 - 300.0;
                    var y = Math.random() * 600.0 + height / 2.0 - 300.0;
                    var vx = Math.random() * 2.0 - 1.0;
                    var vy = Math.random() * 2.0 - 1.0;
                    textureArray[i] = x;
                    textureArray[i + 1] = y;
                    textureArray[i + 2] = vx;
                    textureArray[i + 3] = vy;
                }

                particleVar = gpuCompute.addVariable(
                    'textureParticle',
                    document.getElementById('particleCalculator').textContent,
                    particleTexture);
                gpuCompute.setVariableDependencies(particleVar, [particleVar]);

                uniforms = particleVar.material.uniforms;
                uniforms.deltaTime = { value: 0.0 };
                uniforms.mousePos =
                    new THREE.Uniform(new THREE.Vector2(width / 2.0, height / 2.0));

                var error = gpuCompute.init();
                if (error != null)
                    console.error(error);
            }

            function animate()
            {
                requestAnimationFrame(animate);

                uniforms.deltaTime.value = clock.getDelta();
                gpuCompute.compute();
                particleShaderMat.uniforms.posAndVelocity.value =
                    gpuCompute.getCurrentRenderTarget(particleVar).texture;
                renderer.render(scene, camera);
            }
        </script>
    </head>

    <body>
        <div id="main-div">
            <canvas id="main"></canvas>
        </div>
    </body>
</html>
